<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>API Quickstart &#8212; kraken  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=89a84cc7" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="canonical" href="kraken.re/tutorials/api.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Advanced Usage" href="../advanced/index.html" />
    <link rel="prev" title="Training Tutorial" href="training.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="api-quickstart">
<h1>API Quickstart<a class="headerlink" href="#api-quickstart" title="Link to this heading">¶</a></h1>
<p>Kraken provides routines which are usable by third party tools to access all
functionality of the OCR engine. Most functional blocks, binarization,
segmentation, recognition, and serialization are encapsulated in one high
level method each.</p>
<p>Simple use cases of the API which are mostly useful for debugging purposes are
contained in the <cite>contrib</cite> directory. In general it is recommended to look at
this tutorial, these scripts, or the API reference. The command line drivers
are unnecessarily complex for straightforward applications as they contain lots
of boilerplate to enable all use cases.</p>
<section id="basic-concepts">
<h2>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Link to this heading">¶</a></h2>
<p>The fundamental modules of the API are similar to the command line drivers.
Image inputs and outputs are generally <a class="reference external" href="https://python-pillow.org/">Pillow</a>
objects and numerical outputs numpy arrays.</p>
<p>Top-level modules implement high level functionality while <code class="xref py py-mod docutils literal notranslate"><span class="pre">kraken.lib</span></code>
contains loaders and low level methods that usually should not be used if
access to intermediate results is not required.</p>
</section>
<section id="preprocessing-and-segmentation">
<h2>Preprocessing and Segmentation<a class="headerlink" href="#preprocessing-and-segmentation" title="Link to this heading">¶</a></h2>
<p>The primary preprocessing function is binarization although depending on the
particular setup of the pipeline and the models utilized it can be optional.
For the non-trainable legacy bounding box segmenter binarization is mandatory
although it is still possible to feed color and grayscale images to the
recognizer. The trainable baseline segmenter can work with black and white,
grayscale, and color images, depending on the training data and network
configuration utilized; though grayscale and color data are used in almost all
cases.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">PIL</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken</span><span class="w"> </span><span class="kn">import</span> <span class="n">binarization</span>

<span class="go"># can be any supported image format and mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;foo.png&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bw_im</span> <span class="o">=</span> <span class="n">binarization</span><span class="o">.</span><span class="n">nlbin</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<section id="legacy-segmentation">
<h3>Legacy segmentation<a class="headerlink" href="#legacy-segmentation" title="Link to this heading">¶</a></h3>
<p>The basic parameter of the legacy segmenter consists just of a b/w image
object, although some additional parameters exist, largely to change the
principal text direction (important for column ordering and top-to-bottom
scripts) and explicit masking of non-text image regions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken</span><span class="w"> </span><span class="kn">import</span> <span class="n">pageseg</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">seg</span> <span class="o">=</span> <span class="n">pageseg</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">bw_im</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seg</span>
<span class="go">Segmentation(type=&#39;bbox&#39;,</span>
<span class="go">             imagename=&#39;foo.png&#39;,</span>
<span class="go">             text_direction=&#39;horizontal-lr&#39;,</span>
<span class="go">             script_detection=False,</span>
<span class="go">             lines=[BBoxLine(id=&#39;0ce11ad6-1f3b-4f7d-a8c8-0178e411df69&#39;,</span>
<span class="go">                             bbox=[74, 61, 136, 101],</span>
<span class="go">                             text=None,</span>
<span class="go">                             base_dir=None,</span>
<span class="go">                             type=&#39;bbox&#39;,</span>
<span class="go">                             imagename=None,</span>
<span class="go">                             tags=None,</span>
<span class="go">                             split=None,</span>
<span class="go">                             regions=None,</span>
<span class="go">                             text_direction=&#39;horizontal-lr&#39;),</span>
<span class="go">                    BBoxLine(id=&#39;c4a751dc-6731-4eea-a287-d4b57683f5b0&#39;, ...),</span>
<span class="go">                    ....],</span>
<span class="go">             regions={},</span>
<span class="go">             line_orders=[])</span>
</pre></div>
</div>
<p>All segmentation methods return a <a class="reference internal" href="../api_docs.html#kraken.containers.Segmentation" title="kraken.containers.Segmentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.Segmentation</span></code></a>
object that contains all elements of the segmentation: its type, a list of
lines (either <a class="reference internal" href="../api_docs.html#kraken.containers.BBoxLine" title="kraken.containers.BBoxLine"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.BBoxLine</span></code></a> or
<a class="reference internal" href="../api_docs.html#kraken.containers.BaselineLine" title="kraken.containers.BaselineLine"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.BaselineLine</span></code></a>), a dictionary mapping region types to
lists of regions (<a class="reference internal" href="../api_docs.html#kraken.containers.Region" title="kraken.containers.Region"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.Region</span></code></a>), and one or more line
reading orders.</p>
</section>
<section id="baseline-segmentation">
<h3>Baseline segmentation<a class="headerlink" href="#baseline-segmentation" title="Link to this heading">¶</a></h3>
<p>The baseline segmentation method is based on a neural network that classifies
image pixels into baselines and regions. Because it is trainable, a
segmentation model is required in addition to the image to be segmented and
it has to be loaded first:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken</span><span class="w"> </span><span class="kn">import</span> <span class="n">blla</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">vgsl</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model_path</span> <span class="o">=</span> <span class="s1">&#39;path/to/model/file&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">vgsl</span><span class="o">.</span><span class="n">TorchVGSLModel</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
</pre></div>
</div>
<p>A segmentation model contains a basic neural network and associated metadata
defining the available line and region types, bounding regions, and an
auxiliary baseline location flag for the polygonizer:</p>
<p>Afterwards they can be fed into the segmentation method
<a class="reference internal" href="../api_docs.html#kraken.blla.segment" title="kraken.blla.segment"><code class="xref py py-func docutils literal notranslate"><span class="pre">kraken.blla.segment()</span></code></a> with image objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken</span><span class="w"> </span><span class="kn">import</span> <span class="n">blla</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken</span><span class="w"> </span><span class="kn">import</span> <span class="n">serialization</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">baseline_seg</span> <span class="o">=</span> <span class="n">blla</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baseline_seg</span>
<span class="go">Segmentation(type=&#39;baselines&#39;,</span>
<span class="go">             imagename=&#39;foo.png&#39;,</span>
<span class="go">             text_direction=&#39;horizontal-lr&#39;,</span>
<span class="go">             script_detection=False,</span>
<span class="go">             lines=[BaselineLine(id=&#39;22fee3d1-377e-4130-b9e5-5983a0c50ce8&#39;,</span>
<span class="go">                                 baseline=[[71, 93], [145, 92]],</span>
<span class="go">                                 boundary=[[71, 93], ..., [71, 93]],</span>
<span class="go">                                 text=None,</span>
<span class="go">                                 base_dir=None,</span>
<span class="go">                                 type=&#39;baselines&#39;,</span>
<span class="go">                                 imagename=None,</span>
<span class="go">                                 tags={&#39;type&#39;: &#39;default&#39;},</span>
<span class="go">                                 split=None,</span>
<span class="go">                                 regions=[&#39;f17d03e0-50bb-4a35-b247-cb910c0aaf2b&#39;]),</span>
<span class="go">                    BaselineLine(id=&#39;539eadce-f795-4bba-a785-c7767d10c407&#39;, ...), ...],</span>
<span class="go">             regions={&#39;text&#39;: [Region(id=&#39;f17d03e0-50bb-4a35-b247-cb910c0aaf2b&#39;,</span>
<span class="go">                                      boundary=[[277, 54], ..., [277, 54]],</span>
<span class="go">                                      imagename=None,</span>
<span class="go">                                      tags={&#39;type&#39;: &#39;text&#39;})]},</span>
<span class="go">             line_orders=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alto</span> <span class="o">=</span> <span class="n">serialization</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">baseline_seg</span><span class="p">,</span>
<span class="go">                                   image_size=im.size,</span>
<span class="go">                                   template=&#39;alto&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;segmentation_output.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="go">        fp.write(alto)</span>
</pre></div>
</div>
<p>A default segmentation model is supplied and will be used if none is specified
explicitly as an argument.  Optional parameters are largely the same as for the
legacy segmenter, i.e. text direction and masking.</p>
<p>Images are automatically converted into the proper mode for recognition, except
in the case of models trained on binary images as there is a plethora of
different algorithms available, each with strengths and weaknesses. For most
material the kraken-provided binarization should be sufficient, though. This
does not mean that a segmentation model trained on RGB images will have equal
accuracy for B/W, grayscale, and RGB inputs. Nevertheless the drop in quality
will often be modest or non-existent for color models while non-binarized
inputs to a binary model will cause severe degradation (and a warning to that
notion).</p>
<p>Per default segmentation is performed on the CPU although the neural network
can be run on a GPU with the <cite>device</cite> argument. As the vast majority of the
processing required is postprocessing the performance gain will most likely
modest though.</p>
<p>The above API is the most simple way to perform a complete segmentation. The
process consists of multiple steps such as pixel labelling, separate region and
baseline vectorization, and bounding polygon calculation:</p>
<p>It is possible to only run a subset of the functionality depending on one’s
needs by calling the respective functions in <code class="xref py py-mod docutils literal notranslate"><span class="pre">kraken.lib.segmentation</span></code>. As
part of the sub-library the API is not guaranteed to be stable but it generally
does not change much. Examples of more fine-grained use of the segmentation API
can be found in <a class="reference external" href="https://github.com/mittagessen/kraken/blob/main/kraken/contrib/repolygonize.py">contrib/repolygonize.py</a>
and <a class="reference external" href="https://github.com/mittagessen/kraken/blob/main/kraken/contrib/segmentation_overlay.py">contrib/segmentation_overlay.py</a>.</p>
</section>
</section>
<section id="recognition">
<h2>Recognition<a class="headerlink" href="#recognition" title="Link to this heading">¶</a></h2>
<p>Recognition itself is a multi-step process with a neural network producing a
matrix with a confidence value for possible outputs at each time step. This
matrix is decoded into a sequence of integer labels (<em>label domain</em>) which are
subsequently mapped into Unicode code points using a codec. Labels and code
points usually correspond one-to-one, i.e. each label is mapped to exactly one
Unicode code point, but if desired more complex codecs can map single labels to
multiple code points, multiple labels to single code points, or multiple labels
to multiple code points (see the <a class="reference internal" href="../training/rectrain.html#id1"><span class="std std-ref">Codec</span></a> section for further
information).</p>
<p id="recognition-steps">As the customization of this two-stage decoding process is usually reserved
for specialized use cases, sensible defaults are chosen by default: codecs are
part of the model file and do not have to be supplied manually; the preferred
CTC decoder is an optional parameter of the recognition model object.</p>
<p>To perform text line recognition a neural network has to be loaded first. A
<a class="reference internal" href="../api_docs.html#kraken.lib.models.TorchSeqRecognizer" title="kraken.lib.models.TorchSeqRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.lib.models.TorchSeqRecognizer</span></code></a> is returned which is a wrapper
around the <a class="reference internal" href="../api_docs.html#kraken.lib.vgsl.TorchVGSLModel" title="kraken.lib.vgsl.TorchVGSLModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.lib.vgsl.TorchVGSLModel</span></code></a> class seen above for
segmentation model loading.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rec_model_path</span> <span class="o">=</span> <span class="s1">&#39;/path/to/recognition/model&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">load_any</span><span class="p">(</span><span class="n">rec_model_path</span><span class="p">)</span>
</pre></div>
</div>
<p>The sequence recognizer wrapper combines the neural network itself, a
<a class="reference internal" href="../training/rectrain.html#id1"><span class="std std-ref">codec</span></a>, metadata such as if the input is supposed to be
grayscale or binarized, and an instance of a CTC decoder that performs the
conversion of the raw output tensor of the network into a sequence of labels:</p>
<p>Afterwards, given an image, a segmentation and the model one can perform text
recognition. The code is identical for both legacy and baseline segmentations.
Like for segmentation input images are auto-converted to the correct color
mode, except in the case of binary models for which a warning will be raised if
there is a mismatch.</p>
<p>There are two methods for recognition, a basic single model call
<a class="reference internal" href="../api_docs.html#kraken.rpred.rpred" title="kraken.rpred.rpred"><code class="xref py py-func docutils literal notranslate"><span class="pre">kraken.rpred.rpred()</span></code></a> and a multi-model recognizer
<a class="reference internal" href="../api_docs.html#kraken.rpred.mm_rpred" title="kraken.rpred.mm_rpred"><code class="xref py py-func docutils literal notranslate"><span class="pre">kraken.rpred.mm_rpred()</span></code></a>. The latter is useful for recognizing
multi-scriptal documents, i.e. applying different models to different parts of
a document.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken</span><span class="w"> </span><span class="kn">import</span> <span class="n">rpred</span>
<span class="go"># single model recognition</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_it</span> <span class="o">=</span> <span class="n">rpred</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
<span class="go">                    im=im,</span>
<span class="go">                    segmentation=baseline_seg)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">pred_it</span><span class="p">:</span>
<span class="go">        print(record)</span>
</pre></div>
</div>
<p>The output isn’t just a sequence of characters but, depending on the type of
segmentation supplied, a <a class="reference internal" href="../api_docs.html#kraken.containers.BaselineOCRRecord" title="kraken.containers.BaselineOCRRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.BaselineOCRRecord</span></code></a> or
<a class="reference internal" href="../api_docs.html#kraken.containers.BBoxOCRRecord" title="kraken.containers.BBoxOCRRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.BBoxOCRRecord</span></code></a> record object containing the character
prediction, cuts (approximate locations), and confidences.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">cuts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">prediction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">confidences</span>
</pre></div>
</div>
<p>it is also possible to access the original line information:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for baselines</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">type</span>
<span class="s1">&#39;baselines&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">line</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">baseline</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">script</span>

<span class="c1"># for box lines</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">type</span>
<span class="s1">&#39;bbox&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">line</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">script</span>
</pre></div>
</div>
<p>Sometimes the undecoded raw output of the network is required. The <span class="math notranslate nohighlight">\(C
\times W\)</span> softmax output matrix is accessible as the <cite>outputs</cite> attribute on the
<a class="reference internal" href="../api_docs.html#kraken.lib.models.TorchSeqRecognizer" title="kraken.lib.models.TorchSeqRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.lib.models.TorchSeqRecognizer</span></code></a> after each step of the
<a class="reference internal" href="../api_docs.html#kraken.rpred.rpred" title="kraken.rpred.rpred"><code class="xref py py-func docutils literal notranslate"><span class="pre">kraken.rpred.rpred()</span></code></a> iterator. To get a mapping from the label space
<span class="math notranslate nohighlight">\(C\)</span> the network operates in to Unicode code points a codec is used. An
arbitrary sequence of labels can generate an arbitrary number of Unicode code
points although usually the relation is one-to-one.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pred_it</span> <span class="o">=</span> <span class="n">rpred</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">baseline_seg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">pred_it</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">output</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">codec</span><span class="o">.</span><span class="n">l2c</span>
<span class="go">{&#39;\x01&#39;: &#39; &#39;,</span>
<span class="go"> &#39;\x02&#39;: &#39;&quot;&#39;,</span>
<span class="go"> &#39;\x03&#39;: &quot;&#39;&quot;,</span>
<span class="go"> &#39;\x04&#39;: &#39;(&#39;,</span>
<span class="go"> &#39;\x05&#39;: &#39;)&#39;,</span>
<span class="go"> &#39;\x06&#39;: &#39;-&#39;,</span>
<span class="go"> &#39;\x07&#39;: &#39;/&#39;,</span>
<span class="go"> ...</span>
<span class="go">}</span>
</pre></div>
</div>
<p>There are several different ways to convert the output matrix to a sequence of
labels that can be decoded into a character sequence. These are contained in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">kraken.lib.ctc_decoder</span></code> with
<a class="reference internal" href="../api_docs.html#kraken.lib.ctc_decoder.greedy_decoder" title="kraken.lib.ctc_decoder.greedy_decoder"><code class="xref py py-func docutils literal notranslate"><span class="pre">kraken.lib.ctc_decoder.greedy_decoder()</span></code></a> being the default.</p>
</section>
<section id="xml-parsing">
<h2>XML Parsing<a class="headerlink" href="#xml-parsing" title="Link to this heading">¶</a></h2>
<p>Sometimes it is desired to take the data in an existing XML serialization
format like PageXML or ALTO and apply an OCR function on it. The
<code class="xref py py-mod docutils literal notranslate"><span class="pre">kraken.lib.xml</span></code> module includes parsers extracting information into data
structures processable with minimal transformation by the functional blocks:</p>
<p>Parsing is accessed is through the <a class="reference internal" href="../api_docs.html#kraken.lib.xml.XMLPage" title="kraken.lib.xml.XMLPage"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.lib.xml.XMLPage</span></code></a> class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">xml</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">alto_doc</span> <span class="o">=</span> <span class="s1">&#39;/path/to/alto&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_doc</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">XMLPage</span><span class="p">(</span><span class="n">alto_doc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_doc</span>
<span class="go">XMLPage(filename=&#39;/path/to/alto&#39;, filetype=alto)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_doc</span><span class="o">.</span><span class="n">lines</span>
<span class="go">{&#39;line_1469098625593_463&#39;: BaselineLine(id=&#39;line_1469098625593_463&#39;,</span>
<span class="go">                                        baseline=[(2337, 226), (2421, 239)],</span>
<span class="go">                                        boundary=[(2344, 182), (2428, 195), (2420, 244), (2336, 231)],</span>
<span class="go">                                        text=&#39;$pag:39&#39;,</span>
<span class="go">                                        base_dir=None,</span>
<span class="go">                                        type=&#39;baselines&#39;,</span>
<span class="go">                                        imagename=None,</span>
<span class="go">                                        tags={&#39;type&#39;: &#39;$pag&#39;},</span>
<span class="go">                                        split=None,</span>
<span class="go">                                        regions=[&#39;region_1469098609000_462&#39;]),</span>

<span class="go"> &#39;line_1469098649515_464&#39;: BaselineLine(id=&#39;line_1469098649515_464&#39;,</span>
<span class="go">                                        baseline=[(789, 269), (2397, 304)],</span>
<span class="go">                                        boundary=[(790, 224), (2398, 259), (2397, 309), (789, 274)],</span>
<span class="go">                                        text=&#39;$-nor su hijo, De todos sus bienes, con los pactos&#39;,</span>
<span class="go">                                        base_dir=None,</span>
<span class="go">                                        type=&#39;baselines&#39;,</span>
<span class="go">                                        imagename=None,</span>
<span class="go">                                        tags={&#39;type&#39;: &#39;$pac&#39;},</span>
<span class="go">                                        split=None,</span>
<span class="go">                                        regions=[&#39;region_1469098557906_461&#39;]),</span>
<span class="go"> ....}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_doc</span><span class="o">.</span><span class="n">regions</span>
<span class="go">{&#39;$pag&#39;: [Region(id=&#39;region_1469098609000_462&#39;,</span>
<span class="go">                 boundary=[(2324, 171), (2437, 171), (2436, 258), (2326, 237)],</span>
<span class="go">                 imagename=None,</span>
<span class="go">                 tags={&#39;type&#39;: &#39;$pag&#39;})],</span>
<span class="go"> &#39;$pac&#39;: [Region(id=&#39;region_1469098557906_461&#39;,</span>
<span class="go">                 boundary=[(738, 203), (2339, 245), (2398, 294), (2446, 345), (2574, 469), (2539, 1873), (2523, 2053), (2477, 2182), (738, 2243)],</span>
<span class="go">                 imagename=None,</span>
<span class="go">                 tags={&#39;type&#39;: &#39;$pac&#39;})],</span>
<span class="go"> &#39;$tip&#39;: [Region(id=&#39;TextRegion_1520586482298_194&#39;,</span>
<span class="go">                 boundary=[(687, 2428), (688, 2422), (107, 2420), (106, 2264), (789, 2256), (758, 2404)],</span>
<span class="go">                 imagename=None,</span>
<span class="go">                 tags={&#39;type&#39;: &#39;$tip&#39;})],</span>
<span class="go"> &#39;$par&#39;: [Region(id=&#39;TextRegion_1520586482298_193&#39;,</span>
<span class="go">                 boundary=[(675, 3772), (687, 2428), (758, 2404), (789, 2256), (2542, 2236), (2581, 3748)],</span>
<span class="go">                 imagename=None,</span>
<span class="go">                 tags={&#39;type&#39;: &#39;$par&#39;})]</span>
<span class="go">}</span>
</pre></div>
</div>
<p>The parser is aware of reading order(s), thus the basic properties accessing
lines and regions are unordered dictionaries. Reading orders can be accessed
separately through the <cite>reading_orders</cite> property:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_doc</span><span class="o">.</span><span class="n">region_orders</span>
<span class="go">{&#39;line_implicit&#39;: {&#39;order&#39;: [&#39;line_1469098625593_463&#39;,</span>
<span class="go">                             &#39;line_1469098649515_464&#39;,</span>
<span class="go">                             ...</span>
<span class="go">                            &#39;line_1469099255968_508&#39;],</span>
<span class="go">                   &#39;is_total&#39;: True,</span>
<span class="go">                   &#39;description&#39;: &#39;Implicit line order derived from element sequence&#39;},</span>
<span class="go">&#39;region_implicit&#39;: {&#39;order&#39;: [&#39;region_1469098609000_462&#39;,</span>
<span class="go">                              ...</span>
<span class="go">                             &#39;TextRegion_1520586482298_193&#39;],</span>
<span class="go">                    &#39;is_total&#39;: True,</span>
<span class="go">                    &#39;description&#39;: &#39;Implicit region order derived from element sequence&#39;},</span>
<span class="go">&#39;region_transkribus&#39;: {&#39;order&#39;: [&#39;region_1469098609000_462&#39;,</span>
<span class="go">                                 ...</span>
<span class="go">                                &#39;TextRegion_1520586482298_193&#39;],</span>
<span class="go">                    &#39;is_total&#39;: True,</span>
<span class="go">                    &#39;description&#39;: &#39;Explicit region order from `custom` attribute&#39;},</span>
<span class="go">&#39;line_transkribus&#39;: {&#39;order&#39;: [&#39;line_1469098625593_463&#39;,</span>
<span class="go">                               ...</span>
<span class="go">                               &#39;line_1469099255968_508&#39;],</span>
<span class="go">                     &#39;is_total&#39;: True,</span>
<span class="go">                     &#39;description&#39;: &#39;Explicit line order from `custom` attribute&#39;},</span>
<span class="go">&#39;o_1530717944451&#39;: {&#39;order&#39;: [&#39;region_1469098609000_462&#39;,</span>
<span class="go">                              ...</span>
<span class="go">                              &#39;TextRegion_1520586482298_193&#39;],</span>
<span class="go">                   &#39;is_total&#39;: True,</span>
<span class="go">                   &#39;description&#39;: &#39;Regions reading order&#39;}}</span>
</pre></div>
</div>
<p>Reading orders are created from different sources, depending on the content of
the XML file. Every document will contain at least implicit orders for lines
and regions (<cite>line_implicit</cite> and <cite>region_implicit</cite>) sourced from the sequence
of line and region elements. There can also be explicit additional orders
defined by the standard reading order elements, for example <cite>o_1530717944451</cite>
in the above example. In Page XML files reading orders defined with the
Transkribus style custom attribute are also recognized.</p>
<p>To access the lines or regions of a document in a particular order:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parsed_doc</span><span class="o">.</span><span class="n">get_sorted_lines</span><span class="p">(</span><span class="n">ro</span><span class="o">=</span><span class="s1">&#39;line_implicit&#39;</span><span class="p">)</span>
<span class="go">[BaselineLine(id=&#39;line_1469098625593_463&#39;,</span>
<span class="go">              baseline=[(2337, 226), (2421, 239)],</span>
<span class="go">              boundary=[(2344, 182), (2428, 195), (2420, 244), (2336, 231)],</span>
<span class="go">              text=&#39;$pag:39&#39;,</span>
<span class="go">              base_dir=None,</span>
<span class="go">              type=&#39;baselines&#39;,</span>
<span class="go">              imagename=None,</span>
<span class="go">              tags={&#39;type&#39;: &#39;$pag&#39;},</span>
<span class="go">              split=None,</span>
<span class="go">              regions=[&#39;region_1469098609000_462&#39;]),</span>
<span class="go"> BaselineLine(id=&#39;line_1469098649515_464&#39;,</span>
<span class="go">              baseline=[(789, 269), (2397, 304)],</span>
<span class="go">              boundary=[(790, 224), (2398, 259), (2397, 309), (789, 274)],</span>
<span class="go">              text=&#39;$-nor su hijo, De todos sus bienes, con los pactos&#39;,</span>
<span class="go">              base_dir=None,</span>
<span class="go">              type=&#39;baselines&#39;,</span>
<span class="go">              imagename=None,</span>
<span class="go">              tags={&#39;type&#39;: &#39;$pac&#39;},</span>
<span class="go">              split=None,</span>
<span class="go">              regions=[&#39;region_1469098557906_461&#39;])</span>
<span class="go">...]</span>
</pre></div>
</div>
<p>The recognizer functions do not accept <a class="reference internal" href="../api_docs.html#kraken.lib.xml.XMLPage" title="kraken.lib.xml.XMLPage"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.lib.xml.XMLPage</span></code></a> objects
directly which means that for most practical purposes these need to be
converted into <a class="reference internal" href="../api_docs.html#kraken.containers.Segmentation" title="kraken.containers.Segmentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">container</span></code></a> objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation</span> <span class="o">=</span> <span class="n">parsed_doc</span><span class="o">.</span><span class="n">to_container</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_it</span> <span class="o">=</span> <span class="n">rpred</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
<span class="go">                    im=im,</span>
<span class="go">                    segmentation=segmentation)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">pred_it</span><span class="p">:</span>
<span class="go">        print(record)</span>
</pre></div>
</div>
</section>
<section id="serialization">
<h2>Serialization<a class="headerlink" href="#serialization" title="Link to this heading">¶</a></h2>
<p>The serialization module can be used to transform results returned by the
segmenter or recognizer into a text based (most often XML) format for archival.
The module renders <a class="reference external" href="https://jinja.palletsprojects.com">jinja2</a> templates,
either ones <a class="reference internal" href="../api_docs.html#templates"><span class="std std-ref">packaged</span></a> with kraken or supplied externally,
through the <a class="reference internal" href="../api_docs.html#kraken.serialization.serialize" title="kraken.serialization.serialize"><code class="xref py py-func docutils literal notranslate"><span class="pre">kraken.serialization.serialize()</span></code></a> function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">serialization</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">alto_seg_only</span> <span class="o">=</span> <span class="n">serialization</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">baseline_seg</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;alto&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span> <span class="o">=</span> <span class="p">[</span><span class="n">record</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">pred_it</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">pred_it</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="n">records</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alto</span> <span class="o">=</span> <span class="n">serialization</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="s1">&#39;alto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="go">        fp.write(alto)</span>
</pre></div>
</div>
<p>The serialization function accepts arbitrary
<a class="reference internal" href="../api_docs.html#kraken.containers.Segmentation" title="kraken.containers.Segmentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.Segmentation</span></code></a> objects, which may contain textual or
only segmentation information. As the recognizer returns
<a class="reference internal" href="../api_docs.html#kraken.containers.ocr_record" title="kraken.containers.ocr_record"><code class="xref py py-class docutils literal notranslate"><span class="pre">ocr_records</span></code></a> which cannot be serialized
directly it is necessary to either construct a new
<a class="reference internal" href="../api_docs.html#kraken.containers.Segmentation" title="kraken.containers.Segmentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">kraken.containers.Segmentation</span></code></a> from scratch or insert them into the
segmentation fed into the recognizer (<a class="reference internal" href="../api_docs.html#kraken.containers.ocr_record" title="kraken.containers.ocr_record"><code class="xref py py-class docutils literal notranslate"><span class="pre">ocr_records</span></code></a> subclass <a class="reference internal" href="../api_docs.html#kraken.containers.BaselineLine" title="kraken.containers.BaselineLine"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaselineLine</span></code></a>/<a class="reference internal" href="../api_docs.html#kraken.containers.BBoxLine" title="kraken.containers.BBoxLine"><code class="xref py py-class docutils literal notranslate"><span class="pre">BBoxLine</span></code></a> The container classes are immutable data classes,
therefore it is necessary for simple insertion of the records to use
<cite>dataclasses.replace</cite> to create a new segmentation with a changed lines
attribute.</p>
</section>
<section id="training">
<h2>Training<a class="headerlink" href="#training" title="Link to this heading">¶</a></h2>
<p>Training is largely implemented with the <a class="reference external" href="https://www.pytorchlightning.ai/">pytorch lightning</a> framework. There are separate
<cite>LightningModule`s for recognition and segmentation training and a small
wrapper around the lightning’s `Trainer</cite> class that mainly sets up model
handling and verbosity options for the CLI.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib.train</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecognitionModel</span><span class="p">,</span> <span class="n">KrakenTrainer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ground_truth</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;training/*.xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">training_files</span> <span class="o">=</span> <span class="n">ground_truth</span><span class="p">[:</span><span class="mi">250</span><span class="p">]</span> <span class="c1"># training data is shuffled internally</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evaluation_files</span> <span class="o">=</span> <span class="n">ground_truth</span><span class="p">[</span><span class="mi">250</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">RecognitionModel</span><span class="p">(</span><span class="n">training_data</span><span class="o">=</span><span class="n">training_files</span><span class="p">,</span> <span class="n">evaluation_data</span><span class="o">=</span><span class="n">evaluation_files</span><span class="p">,</span> <span class="n">format_type</span><span class="o">=</span><span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="n">augment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span> <span class="o">=</span> <span class="n">KrakenTrainer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise for a baseline and region segmentation model:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib.train</span><span class="w"> </span><span class="kn">import</span> <span class="n">SegmentationModel</span><span class="p">,</span> <span class="n">KrakenTrainer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ground_truth</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;training/*.xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">training_files</span> <span class="o">=</span> <span class="n">ground_truth</span><span class="p">[:</span><span class="mi">250</span><span class="p">]</span> <span class="c1"># training data is shuffled internally</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evaluation_files</span> <span class="o">=</span> <span class="n">ground_truth</span><span class="p">[</span><span class="mi">250</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">SegmentationModel</span><span class="p">(</span><span class="n">training_data</span><span class="o">=</span><span class="n">training_files</span><span class="p">,</span> <span class="n">evaluation_data</span><span class="o">=</span><span class="n">evaluation_files</span><span class="p">,</span> <span class="n">format_type</span><span class="o">=</span><span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="n">augment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span> <span class="o">=</span> <span class="n">KrakenTrainer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p>When the <cite>fit()</cite> method is called the dataset is initialized and the training
commences. Both can take quite a bit of time. To get insight into what exactly
is happening the standard <a class="reference external" href="https://pytorch-lightning.readthedocs.io/en/latest/common/trainer.html#callbacks">lightning callbacks</a>
can be attached to the trainer object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pytorch_lightning.callbacks</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callback</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">kraken.lib.train</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecognitionModel</span><span class="p">,</span> <span class="n">KrakenTrainer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyPrintingCallback</span><span class="p">(</span><span class="n">Callback</span><span class="p">):</span>
<span class="go">    def on_init_start(self, trainer):</span>
<span class="go">        print(&quot;Starting to init trainer!&quot;)</span>

<span class="go">    def on_init_end(self, trainer):</span>
<span class="go">        print(&quot;trainer is init now&quot;)</span>

<span class="go">    def on_train_end(self, trainer, pl_module):</span>
<span class="go">        print(&quot;do something when training ends&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ground_truth</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;training/*.xml&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">training_files</span> <span class="o">=</span> <span class="n">ground_truth</span><span class="p">[:</span><span class="mi">250</span><span class="p">]</span> <span class="c1"># training data is shuffled internally</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evaluation_files</span> <span class="o">=</span> <span class="n">ground_truth</span><span class="p">[</span><span class="mi">250</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">RecognitionModel</span><span class="p">(</span><span class="n">training_data</span><span class="o">=</span><span class="n">training_files</span><span class="p">,</span> <span class="n">evaluation_data</span><span class="o">=</span><span class="n">evaluation_files</span><span class="p">,</span> <span class="n">format_type</span><span class="o">=</span><span class="s1">&#39;xml&#39;</span><span class="p">,</span> <span class="n">augment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span> <span class="o">=</span> <span class="n">KrakenTrainer</span><span class="p">(</span><span class="n">enable_progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">MyPrintingCallback</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="go">Starting to init trainer!</span>
<span class="go">trainer is init now</span>
</pre></div>
</div>
<p>This is only a small subset of the training functionality. It is suggested to
have a closer look at the command line parameters for features as transfer
learning, region and baseline filtering, training continuation, and so on.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/kraken.png" alt="Logo of kraken"/>
            </a></p>
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">API Quickstart</a><ul>
<li><a class="reference internal" href="#basic-concepts">Basic Concepts</a></li>
<li><a class="reference internal" href="#preprocessing-and-segmentation">Preprocessing and Segmentation</a><ul>
<li><a class="reference internal" href="#legacy-segmentation">Legacy segmentation</a></li>
<li><a class="reference internal" href="#baseline-segmentation">Baseline segmentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recognition">Recognition</a></li>
<li><a class="reference internal" href="#xml-parsing">XML Parsing</a></li>
<li><a class="reference internal" href="#serialization">Serialization</a></li>
<li><a class="reference internal" href="#training">Training</a></li>
</ul>
</li>
</ul>

  </div><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tutorials</a><ul>
      <li>Previous: <a href="training.html" title="previous chapter">Training Tutorial</a></li>
      <li>Next: <a href="../advanced/index.html" title="next chapter">Advanced Usage</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
<h3>Versions</h3>
<ul>
  <li><a href="../../2.0.0/index.html">2.0.0</a></li>
  <li><a href="../../3.0/index.html">3.0</a></li>
  <li><a href="../../4.0/index.html">4.0</a></li>
  <li><a href="../../4.1/index.html">4.1</a></li>
  <li><a href="../../4.2.0/index.html">4.2.0</a></li>
  <li><a href="../../4.3.0/index.html">4.3.0</a></li>
  <li><a href="../../5.0.0/index.html">5.0.0</a></li>
  <li><a href="../../5.2/index.html">5.2</a></li>
  <li><a href="../../5.3.0/index.html">5.3.0</a></li>
  <li><a href="../../6.0.0/tutorials/api.html">6.0.0</a></li>
  <li><a href="api.html">main</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2015-2025, Benjamin Kiessling.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/tutorials/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>